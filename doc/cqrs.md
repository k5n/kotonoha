# CQRS化計画

## 概要

現在のDBテーブルは基本的には Query を想定した設計になっており、それをそのまま書き換えている一般的な作りになっています。
しかし今後 Google Drive を経由したデバイス間の同期を実装する予定であり、「同期のための最新状態管理テーブル」を別途用意するつもりです。

Event Sourcing での「イベント」はドメインイベントに近い概念ですが、ここではもっと単純に各テーブルの各レコードを単位とします。
ローカルでの同期前の変更は部分変更を想定して履歴管理します。これを sync_pending_changes テーブルとします。
他デバイスを含む全デバイス間での同期は、各テーブルの最新状態のみを保持する sync_states テーブルを用いて行います。（肥大化を防ぐため）。

CQRS の Command 側が sync_pending_changes と sync_states テーブル、Query 側がその他のDBテーブルとなります。

同期内容には以下を含みます。

- どのデバイスが変更したか
- いつ変更したか
- どのテーブルの変更か
- どのレコードの変更か（id=UUID）
- レコードの変更内容（JSON）

## CQRS 化の目的

CQRS 化の目的は以下の通りです。

- デバイス間の同期を容易にする
    - 各デバイスは sync_states テーブルの更新内容を Google Drive 経由で共有し、他のデバイスの変更内容を取り込むことで同期を実現する
- sync_states テーブル以外を Query 専用に最適化できる
- 各テーブルをクエリに必要なものフィールド以外は content フィールドにJSONで保存することで、DBテーブルのスキーマ変更を最小限にする
    - マイグレーションによる影響を最小限に抑え、アプリのバージョンアップを容易にする
- sync_states 以外のDBテーブルを sync_states テーブルの内容から再構築できるようにすることで、将来的に以下のような利点がある
    - sync_states テーブル以外のテーブルのスキーマ変更が発生しても柔軟に対応できる
    - バックアップやリストアの際に sync_states テーブルを元に他のテーブルを再構築できる

同期が目的であるため、肥大化を防ぐために履歴ではなく最新状態のみを保持します。
特に将来的にスマホアプリ対応も考えているため、デバイスのストレージ容量を圧迫しないようにする必要があります。

## 実装方針

最終的にデバイス間同期を実現する予定だが、まずはそれを想定したDBテーブル設計と実装を行う。
段階的に以下のステップで進める。

1. 既存のDBテーブルの見直しと最適化（完了）
    - 各テーブルのスキーマを見直し、Query に最適化する
    - 不要なカラムの削除や、JSON カラムの追加
2. sync_pending_changes, sync_states テーブルの設計と実装（← 現在これの計画段階）
    - 各テーブルの変更履歴を保存するためのスキーマ設計
    - デバイスIDの決定と管理方法の検討
    - 各操作（Insert, Update, Delete）時に sync_pending_changes, sync_states テーブルにレコードを追加するロジックの実装
3. データベースの移行スクリプトの作成
    - 既存データを新テーブル設計に移行するためのスクリプト作成
    - 移行後のデータ整合性チェック
4. デバイス間同期の実装

## sync_pending_changes,  sync_states テーブルのスキーマ案

### sync_pending_changes テーブル

```sql
CREATE TABLE sync_pending_changes (
    id INTEGER PRIMARY KEY,
    table_name TEXT NOT NULL,
    record_id UUID NOT NULL,
    patch_data JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_sync_pending_changes_created_at ON sync_pending_changes(created_at);
CREATE INDEX IF NOT EXISTS idx_sync_pending_changes_table_record ON sync_pending_changes(table_name, record_id);
```

sync_pending_changes テーブルは、ローカルデバイスでの変更履歴を保存します。
ただし肥大化を防ぐために未同期の変更のみを保存し、同期が完了したら削除します。
このテーブルへは Insert と Delete のみを行い、Update は行いません。

device_id は不要です。ローカルデバイスの変更のみを保存するためです。
patch_data カラムには、変更内容の差分を JSON で保存します。
INSERT であれば patch_data に全フィールドの内容を保存し、UPDATE であれば変更されたフィールドのみを保存します。
差分の形式は JSON Merge Patch（RFC 7396）を想定しています。（配列は置換されることに注意。それが許容できない内容は別テーブルにしてリレーションさせる。）

created_at カラムは、変更が行われた時刻を保存します。
ここに保存するタイムスタンプの仕様については後述します。

### sync_states テーブル

```sql
CREATE TABLE sync_states (
    table_name TEXT NOT NULL,
    record_id UUID NOT NULL,
    record_data JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL,
    device_id UUID NOT NULL,
    synced_at TIMESTAMP,
    PRIMARY KEY (table_name, record_id)
);
CREATE INDEX IF NOT EXISTS idx_sync_states_created_at ON sync_states(created_at);
CREATE INDEX IF NOT EXISTS idx_sync_states_table_name ON sync_states(table_name);
```

このテーブルは各デバイス間で共有された後の（その後の自デバイスの変更も含む）最新状態を保存します。
つまりこのテーブルの内容が Single Source of Truth であり、現時点の最新スナップショットです。

このテーブルには常に最新の情報のみを保持すればよく、UPSERT を使用します。
削除は Soft Delete のみで、レコード内容の deleted_at を設定することで表現します。
（このテーブルの情報を元に各 table_name のテーブル内容を更新・復元する際に UPSERT だけを使用するか、削除されたものは物理削除するかはこの仕様では決めません）
record_data カラムには、レコード内容全体を JSON で保存します（SQLite3 は 3.45.0 から JSONB をサポート）。

created_at のタイムスタンプ仕様については後述します。
device_id カラムには、最後に変更を行ったデバイスのIDを保存します。問題追跡用であり、同期ロジックには使用しません。
synced_at カラムには、そのレコードが最後に同期された時刻を保存します。外部と同期した時刻であり、ローカルでのレコード変更時には値を保持します。ローカルで新しく追加されたレコードの場合は NULL が格納されます。問題追跡用であり、同期ロジックには使用しません。

変更パッチの適用例： jsonb_patch 関数が利用できる

```sql
-- 他デバイスからの変更(new_patch)を、既存のデータ(record_data)にマージ
UPDATE sync_states 
SET record_data = jsonb_patch(record_data, :new_patch),
    created_at = :new_hlc_timestamp
WHERE table_name = :table_name AND record_id = :record_id;
```

## デバイス間同期の方法

各デバイスはアプリ開始時、アプリ終了時、あるいはユーザーの手動操作で、利用者個人の Google Drive に sync_states テーブルの内容をアップロード・ダウンロードします。

ダウンロードは

- 共有ストレージから他のデバイスがアップロードしたファイルのうち、
  自身が最後にアップロードしたタイムスタンプ以降（バッファも持たせて少し前から）のファイルを取得
- 自身がまだ取り込んでいないレコードを抽出
- ローカルの sync_states テーブルに取り込み

という形で行います。

アップロードは

- ローカルの sync_states テーブルから、まだアップロードしていないレコードを抽出
- 共有ストレージにアップロード

という形で行います。

アップロードするファイルには sync_pending_changes テーブルの内容を１つのJSONファイルにまとめ、アップロードした時刻のタイムスタンプとデバイスIDをファイル名として含めます。

- 例: patch_{device_id}_{timestamp}.json

タイムスタンプは Google Drive 側の時刻を使用します。
これにより自身が最後にアップロードしたレコードがどこまでかを把握できます。

Google Drive 側のフォルダ内ファイル数が増えすぎないように、また対象ファイル数を絞れるようにするために、年月日単位でサブフォルダを作成し、その中にファイルをアップロードします。
アップロード処理中にアプリが強制終了した場合に備え、アップロード完了後に sync_pending_changes テーブルの内容を削除します。

## テーブル更新のトランザクション

sync_pending_changes, sync_states テーブルへの更新と、対象テーブルの更新は同一トランザクション内で行います。
これを怠ると「履歴はあるが実データが変わっていない」といった不整合が発生し、同期の信頼性が崩れます。

これはそのデバイスでのユーザー操作などによる通常のアプリ動作時の変更だけでなく、他デバイスからの同期内容を取り込む際の更新処理にも同様に適用します。
（sync_pending_changes は更新されませんが、ルールとしては同じと言えます）

## created_at に使うタイムスタンプ

複数デバイスでの同期では各デバイスで時刻がずれる可能性があります。
同期はリアルタイムに行われるわけではなく、どうやっても同期と同期の間に他のデバイスで行われた変更との競合が発生する可能性があります。
タイムスタンプで保証できるのは「そのデバイスが前回同期してから今回同期するまでの間に行われた変更かどうか？」のみであり、「その間に行われた変更のタイムスタンプが正確どうか？」を保証できません。

その最低限の保証を行い、「ユーザーの責任」とする範囲を「同期と同期の間に複数デバイスで行われた同時編集による競合」に留めることを目標とします。

- 「自デバイスが前回同期してから今回同期するまでの間」に他デバイスで行われた変更については古いデータで上書きされることを完全には防げない
- それ以外の期間に他デバイスで行われた変更については古いデータで上書きすることを防止する

そのために HLC（Hybrid Logical Clock）の考え方を取り入れます。

```
timestamp = max(system_timestamp, max_seen_timestamp + 1)
```

system_timestamp は各デバイスのローカル時刻を使用します。
max_seen_timestamp はそのデバイスがこれまでに見た中（つまり sync_states テーブル内の synced_at が NULL でないレコードの中）で最大の timestamp 値です。

これにより、もしそのデバイスのローカル時刻がずれていても、少なくとも過去に見た max_seen_timestamp よりは大きい値がタイムスタンプとして設定されます。
そのデバイスが最後に同期した後の変更であることだけは保証できます。

しかしこの方法では system_timestamp が未来に大きくズレている場合に、timestamp が不自然に大きくなることを防げません。
（例えば Linux と Windows のデュアルブートのマシンで、互いの OS の RTC 仕様が異なっているために、OS が時刻を同期するまで日本では９時間時間がズレることがあります）
このことが他のデバイスでの max_seen_timestamp にも影響を与え、連鎖的に timestamp が実際の時刻より大きくなってしまう可能性があります。
そのため同期の際に Google Drive 側の modifiedTime も参照し、取り込むファイル内の各 timestamp が modifiedTime より５分以上未来になっている場合は、modifiedTime を timestamp として扱う形にします。

```
timestamp = min(timestamp, google_drive_modified_time + 5 minutes)
```

これにより以下が保証されます。

- デバイスのローカル時刻が過去にズレている場合、少なくとも max_seen_timestamp（自デバイス/他デバイスの最終 timestamp） よりは大きい timestamp が設定される
- デバイスのローカル時刻が未来にズレている場合、少なくとも次に同期した際の Google Drive 側の modifiedTime + 5 minutes よりは大きくならない

## Google Drive 側のスナップショット作成と同期内容ログの肥大化対策

Google Drive 側にアップロードされる更新内容ログも肥大化するため、一定期間経過したものはマージする処理が必要です。
その月の最初に Google Drive に同期したデバイスは、現在の sync_states テーブルの内容を現時点のスナップショットとしてアップロードし、過去のログをまとめて削除します。

他のデバイスが同時にこれを行わないようにするために、処理開始前に先にロックファイル（ロックファイルであることとデバイス番号をファイル名に含む）をアップロードし、処理終了後に削除する形にします。
処理開始時に他のデバイスのロックファイルが存在する場合は、他のデバイスが処理中とみなして処理をスキップします。
デッドロックを防ぐために、ロックファイルにはタイムスタンプも含め、一定時間以上経過している場合は強制的にロックを解除する形にします。

### ファイルの完全削除

通常の削除をしてもゴミ箱に残るため、容量を圧迫します。Google Drive API で削除する際は files.delete (完全に削除) を利用します。

### 初期同期

始めて利用するデバイスでは、最新のスナップショットとそれ以降の更新ログを全て取り込む形で初期同期を行います。

## 免責事項

デバイス間の同期に関しては、競合解決をどのように行うかが重要なポイントとなります。
基本的にはタイムスタンプが一番新しいものを適用していく方針ですが、タイムスタンプをサーバー管理していないため、各デバイスで時刻がずれる可能性があります。

現時点では、各デバイスのローカル時刻を信頼する形で実装を進める予定です。
デバイスの時刻同期はユーザーの責任とします。
デバイスの時刻が合っていないために古いデータで上書きされてしまうリスクはありますが、最終的にはユーザーが手動で修正することを想定しています。
同期はあくまでユーザーの所有するデバイス同士で行われるものに限定され、最低限「同期と同期の間に複数デバイスで行われた同時編集による競合」のみに影響を留めるように設計しており、大きな問題にはならないと考えています。

同期はリアルタイムで行われるわけではないため、同じユーザーが別のデバイスで同時に操作を行うと、タイムスタンプが正確だとしてもデータの不整合が発生する可能性があります。
つまりデータの変更操作は現在のデータの状態に依存して行われるため、あるデバイスで一連の変更操作を行った最終結果と、別のデバイスで同時に行われた変更操作の結果が、例えタイムスタンプが正しかったとして全てが最新のデータになったとしても、最終的なデータ状態が意図しないものになる可能性があります（蓋然性は低）。
この点もユーザーの責任とし、ユーザーが手動で修正することを想定しています。
アプリとしては複数デバイスでの同時操作はサポートせず、避けるように注意喚起を行う予定です。

現実的には Google Drive の保存場所を複数ユーザーで共有される場所に設定することで、複数ユーザーで同じデータを共有することも可能ですが、そういった使い方はサポート対象外とします。
