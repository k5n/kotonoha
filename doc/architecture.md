# アーキテクチャ解説

## 各ディレクトリの責務と分割理由

このアプリケーションのフロントエンドは、**レイヤードアーキテクチャ**を採用しています。これにより、関心事を明確に分離し、アプリケーションの**保守性**、**テスト容易性**、**再利用性**を高めることを目的としています。各レイヤーはそれぞれ特定の役割を担い、依存関係の方向を一定に保つことで、変更に強く、スケールしやすい構造を実現します。

以下に、各ディレクトリの役割と、そのように分割する理由を説明します。

`src/routes` は `presentation` レイヤーに含まれますが、SvelteKitのルーティングの仕組みを利用しています。それ以外は `src/lib` 以下に配置されます。

### 1. `presentation` レイヤー (UI層)

ユーザーが見て、直接操作する部分全体を担当します。SvelteコンポーネントやUIに関連するロジック、型定義などが含まれます。

* **このレイヤーに分割する理由:**
    * **UIロジックの分離:** アプリケーションの見た目やユーザー操作に関するコードを、ビジネスロジックから完全に切り離します。これにより、UIデザイナーやフロントエンド開発者は、アプリケーションの核となるロジックを意識することなく、UIの改修に集中できます。
    * **フレームワークへの依存を局所化:** SvelteやUIライブラリへの依存をこのレイヤーに閉じ込めます。将来的にUIフレームワークを変更する際も、他のレイヤーへの影響を最小限に抑えることができます。

#### 1.1. `presentation/components/`

ボタンやモーダル、リストアイテムなど、アプリケーション内で再利用可能なUI部品を配置します。

* **このディレクトリに分割する理由:**
    * **UIの再利用性と一貫性の向上:** 共通のUIパーツをコンポーネント化して一元管理することで、何度も同じコードを書く必要がなくなり、アプリケーション全体のデザインや挙動に一貫性を持たせることができます。
    * **開発効率の向上:** 小さな部品を組み合わせて大きな画面を構築する（コンポーネント指向開発）ことで、見通しが良くなり、開発や修正が容易になります。

#### 1.2. `presentation/types/`

UIの表示に特化したデータ型を定義します。複数のコンポーネントで共有されるデータ型をここに配置します。

* **このディレクトリに分割する理由:**
    * **表示用データとドメインデータの分離:** アプリケーションの核となるデータ構造（ドメインエンティティ）と、UIが表示のために必要とするデータ構造を区別するためです。例えば、「編集中かどうか」のフラグや、フォーマット済みの文字列など、純粋なビジネスデータではない情報をUI表示用の型として定義することで、ドメイン層をクリーンに保ちます。

### 2. `application` レイヤー (アプリケーション層)

ユーザーの操作を起点とした、具体的なアプリケーションの機能（ユースケース）を実装する層です。UIとドメイン層、インフラ層の橋渡し役となります。

* **このレイヤーに分割する理由:**
    * **処理フローの明確化:** 「エピソードを追加する」「単語カードを作成する」といった、ユーザーが行う一連の操作を１つのユースケースとして定義します。これにより、アプリケーションが何をするのかが明確になり、機能単位での把握やテストが容易になります。
    * **UIとビジネスロジックの分離:** UIは「何をしたいか」をこの層に伝えるだけでよく、具体的な処理手順を知る必要はありません。逆にこの層は、UIがボタンなのかリンクなのかを気にする必要がなく、責務を明確に分離できます。

#### 2.1. `application/usecases/`

「新しいエピソードを追加する」など、具体的なユーザーの操作に対応する処理フローを記述します。

* **このディレクトリに分割する理由:**
    * **機能の発見と管理の容易化:** 1つのファイルが1つのユースケースに対応するように分割することで、特定の機能に関するコードがどこにあるのかを簡単に見つけられます。機能の追加や修正も、他のユースケースへの影響を心配することなく行えます。

#### 2.2. `application/stores/`

複数のコンポーネントやページをまたいで共有される、アプリケーション全体の状態（State）を管理します。

* **このディレクトリに分割する理由:**
    * **状態管理の一元化:** アプリケーションの状態をグローバルなストアで一元管理することで、コンポーネント間で複雑なデータの受け渡し（プロパティのバケツリレー）をする必要がなくなります。これにより、状態の変更が予測可能になり、デバッグが容易になります。

### 3. `domain` レイヤー (ドメイン層)

アプリケーションの最も核となるビジネスルールとデータ構造（エンティティ）を定義する層です。このアプリケーションが「何であるか」を表現します。

* **このレイヤーに分割する理由:**
    * **ビジネスロジックの純粋性と独立性の確保:** このレイヤーは、フレームワーク、UI、データベースといった外部の技術的関心事から完全に独立しています。純粋なTypeScript/Rustのロジックで記述されるため、環境に依存しないテストが非常に容易です。
    * **アプリケーションの安定性の向上:** UIやデータベースの技術が変わっても、このドメイン層のコードは変更する必要がありません。アプリケーションの根幹部分が安定しているため、長期的な保守性が劇的に向上します。

#### 3.1. `domain/entities/`

アプリケーションの核となるデータ構造（例: `Episode`, `SentenceCard`）を型として定義します。

* **このディレクトリに分割する理由:**
    * **アプリケーションの語彙の統一:** アプリケーション内で使われる重要な「モノ」や「概念」を明確に定義し、共通の言葉として扱うためです。これにより、開発者間の認識のズレを防ぎ、コードの意図が伝わりやすくなります。

#### 3.2. `domain/services/`

特定のエンティティには属さない、ドメイン固有のロジックや計算処理を配置します。

* **このディレクトリに分割する理由:**
    * **関心の分離:** 複数のエンティティにまたがる複雑なビジネスルールや、単一のエンティティの責務とは言えないようなドメインロジックをここに集約します。これにより、エンティティ自体は自身のデータとそれに付随する単純なロジックに集中でき、モデルが不必要に肥大化するのを防ぎます。

### 4. `infrastructure` レイヤー (インフラ層)

データベース、外部API、ファイルシステムといった、アプリケーションの外部にあるシステムとの通信を担当するすべての技術的な実装を配置します。

* **このレイヤーに分割する理由:**
    * **外部システムへの依存の隔離:** データベースの操作方法やAPIの呼び出し方といった「どうやって実現するか」という実装の詳細を、アプリケーションの他の部分から隠蔽します。例えば、将来データベースをSQLiteから別のものに変更する場合、修正はこのレイヤー内に限定されます。
    * **テストの容易化:** `application`層をテストする際に、このレイヤーをモック（偽物）に差し替えることが容易になります。これにより、実際のデータベースやネットワーク通信なしに、アプリケーションロジックの単体テストを高速かつ安定して実行できます。

#### 4.1. `infrastructure/contracts/`

外部システム（特にTauriバックエンド）と通信する際に使われるデータ転送オブジェクト（DTO）の型を定義します。

* **このディレクトリに分割する理由:**
    * **内部と外部のデータ構造の分離:** アプリケーション内部で使うデータ構造 (`domain/entities`)と、API通信で使われるデータ構造を明確に分離します。APIの仕様変更（例: キーの名前が変わる）が、アプリケーションの核であるドメイン層に直接影響を与えるのを防ぐための緩衝材（クッション）の役割を果たします。

#### 4.2. `infrastructure/repositories/`

データベースやバックエンドAPIとの具体的なデータ送受信処理（Tauriコマンドの呼び出しなど）を実装します。

* **このディレクトリに分割する理由:**
    * **データ永続化ロジックの抽象化:** `application`層は、「エピソードを保存する」という抽象的な命令をリポジトリに対して行うだけでよく、その裏側でTauriコマンドが呼ばれ、SQLが実行されるといった具体的な実装を意識する必要がなくなります。これにより、`application`層は本来の責務であるユースケースの実現に集中できます。